### 2.6 差错控制

在数据传输中由于受到干扰噪声等问题，所以总是不可避免的出现随机性错误，因此需要采用有效的差错控制方法，在数据通信中常用的是检错码和纠错码。
检错码仅能检测误码;纠错码则兼有纠错和检错能力，当发现不可纠正的错误时可以发出错误指示。

#### 2.6.1 码距和检错、纠错的关系

在一个编码系统中，将一个码字变成另一个码字时必须改变的最小位数就是码字之间的距离，简称码距。例如，个编码系统的码距就是整个编码系统中任意(所有)两个码字的最小距离。若一个编码系统有四种编码:0000.0011、1100、1111，此编码系统中0000与1111的码距为4;0000与0011的码距为2，是此编码系统的最小码距。因此该编码系统的码距为2。
首先大家要了解以下两个概念
(1)在一个码组内为了检测e个误码，要求最小码距应该满足d>e+1
(2)在一个码组内为了纠正t个误码，要求最小码距应该满足d≥2t+1所以要想实现检错和纠错，就必须拉大编码系统的码距，在实际中，我们可以通过用户信息+校验码来组成检错码或纠错码，实现码距的扩大。**常见的检错码有奇偶校验码、CRC校验码，纠错码有海明校验码等**。

#### 2.6.2 奇偶校验

奇偶校验码是最简单的检错码，由于实现起来比较容易而被广泛采用。这种码的校验关系可以用一个简单的方程来表示。设要传送用户比特信息为C1C2C3C4C5，其中校验码为C6。

经过编码以后变成6比特编码码字，其中校验位C6应满足C1+C2+C3+C4+C5+C6=0(或1)。

**算式中的加法是模2加。**上式的右边等于零称为偶校验，此时等式的右边含偶数个1;等于1就是奇校验，则含奇数个
在接收方，将收到C1,C2.C6比特进行累加，检查其是否符合式的关系。如果收到的码组符合奇偶校验关系，则认为传输没有错。实际上，它是可能错的。因为，如果偶数位发生错误，则接收方根据奇偶校验关系仍然认为没有错误。奇偶校验码可以发现所有奇数个错误。在上例中，信息位数k=5，码组位数n=6，所以编码率Rc=5/6。奇偶校验码的编码率可以做得很高。

#### 2.6.3 海明校验码

海明校验码是在数据中间加入几个校验码，均匀拉大码距，将数据的每个二进制位分配在几个奇偶校验组里，当某一位出错时，会引起几个校验位的值发生变化。
m个信息位，需要加入的海明校验码个数为k，具有2K个校验信息，1个校验信息用来指出“没有错误”，其余2K-1个指出错误发生在哪一位，所以满足m+k+1≤2K
对于海明校验码校验位存放位置:一般情况海明检验码是放置在二的幂次位上的，即“1,2,4,8,16.”。
例如，信息码101101100采用偶校验，如图2-7所示。

![image-20250319100325810](http://cdn.jsdelivr.net/gh/flamesusr/picgo/img/202503191003752.png)

海明校验码的监督关系式如下。
$$
\begin{align*}
B1 \oplus B3 \oplus B5 \oplus B7 \oplus B9 \oplus B11 \oplus B13 &= 0; \\
B2 \oplus B3 \oplus B6 \oplus B7 \oplus B10 \oplus B11 &= 0; \\
B4 \oplus B5 \oplus B6 \oplus B7 \oplus B12 \oplus B13 &= 0; \\
B8 \oplus B9 \oplus B10 \oplus B11 \oplus B12 \oplus B13 &= 0.
\end{align*}
$$
由监督关系式可以看出，信息位B3受校验位B1、B2的监督，信息位B5受校验位B1、B4的监督，信息位B6受校验位B2、B4的监督，信息位B7受校验位B1、B2、B4的监督，依此类推，假设有14位，那么第14位应该受校验位B2、B4、B8的监督。所以可以算出B1、B2、B4、B8的值。
将结果填入图2-7，得到经过差错编码的数据串，如图2-8所示

![image-20250319100420652](http://cdn.jsdelivr.net/gh/flamesusr/picgo/img/202503191004636.png)

如果给出一个加入了校验码的信息，并说明有一位错误，则可以采用基本相同的方法找出这个错误的位。
例如，监督关系式如下。
$$
\begin{align*}
B1 \oplus B3 \oplus B5 \oplus B7 \oplus B9 \oplus B11 \oplus B13 &= 1 \oplus 1 \oplus 0 \oplus 1 \oplus 0 \oplus 0 \oplus 0 = 1; \\
B2 \oplus B3 \oplus B6 \oplus B7 \oplus B10 \oplus B11 &= 1 \oplus 1 \oplus 1 \oplus 1 \oplus 1 \oplus 0 = 1; \\
B4 \oplus B5 \oplus B6 \oplus B7 \oplus B12 \oplus B13 &= 0 \oplus 0 \oplus 1 \oplus 1 \oplus 0 \oplus 0 = 0; \\
B8 \oplus B9 \oplus B10 \oplus B11 \oplus B12 \oplus B13 &= 0 \oplus 0 \oplus 1 \oplus 0 \oplus 0 \oplus 0 = 1.
\end{align*}\begin{align*}
B1 \oplus B3 \oplus B5 \oplus B7 \oplus B9 \oplus B11 \oplus B13 &= 1 \oplus 1 \oplus 0 \oplus 1 \oplus 0 \oplus 0 \oplus 0 = 1; \\
B2 \oplus B3 \oplus B6 \oplus B7 \oplus B10 \oplus B11 &= 1 \oplus 1 \oplus 1 \oplus 1 \oplus 1 \oplus 0 = 1; \\
B4 \oplus B5 \oplus B6 \oplus B7 \oplus B12 \oplus B13 &= 0 \oplus 0 \oplus 1 \oplus 1 \oplus 0 \oplus 0 = 0; \\
B8 \oplus B9 \oplus B10 \oplus B11 \oplus B12 \oplus B13 &= 0 \oplus 0 \oplus 1 \oplus 0 \oplus 0 \oplus 0 = 1.
\end{align*}
$$
#### 2.6.4 CRC校验码

海明校验码过于复杂，而CRC检验码的实现原理十分易于用硬件实现，因此广泛地应用于计算机网络上的差错控制。
计算CRC校验码基于CRC生成多项式，如原始报文为11001010101，其生成多项式为x*+x3+x+1。计算时在原始报文的后面添加若干0(等于校验码的位数，而生成多项式的最高幂次就是校验位的位数，本题中使用该生成多项式产生的校验码为4位)作为被除数，除以生成多项式所对应的二进制数(根据其幂次的值决定，得到11011，因为生成多项式中除了没有x?，其他位都有)。使用模2除，得到的商就是校验码。将0011添加到原始报文的后面就是结果即110010101010011，如图2-9所示。
检查信息码是否出现了CRC错误的计算很简单，只需用待检査的信息码做被除数，除以生成多项式。如果能够整除，则说明没有错误;否则出错。另外要注意，当CRC检查出现错误时，它不会纠错，通常是让信息的发送方重发一遍。

![image-20250319101040335](http://cdn.jsdelivr.net/gh/flamesusr/picgo/img/202503191010834.png)
