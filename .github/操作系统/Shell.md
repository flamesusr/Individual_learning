## Shell解析器

```shell
cat /etc/shells				
```

| 解析器类型    | 介绍                                                         |
| ------------- | ------------------------------------------------------------ |
| /bin/sh       | Bourne Shell,是UNIX最初使用的shell;                          |
| /bin/bash     | Bourne Again Shell它是Bourne Shell的扩展，简称bash，是LinuxOS默认shell,有灵活和强大的编辑接口，同时又很友好的用户界面，交互性很强； |
| /sbin/nologin | 未登录解析器,  shell设置为/sbin/nologin 是用于控制用户禁止登陆系统的, 有时候有些服务，比如邮件服务，大部分都是用来接收主机的邮件而已，并不需要登陆 |
| /bin/dash     | dash（Debian Almquist Shell），也是一种 Unix shell。它比 Bash 小，只需要较少的磁盘空间，但是它的对话性功能也较少，交互性较差。 |
| /bin/csh      | C Shell是C语言风格Shell                                      |
| /bin/tcsh     | 是C Shell的一个扩展版本。                                    |

## Shell脚本文件编写规范

shell脚本文件就是一个文本文件,  后缀名建议使用 `.sh` 结尾

首行需要设置Shell解析器的类型, 语法

```shell
#!/bin/bash
```

单行注释

```shell
# 注释内容
```

多行注释

```shell
/*
这是一个多行注释
继续注释内容
*/
```

## 脚本文件的常用执行3种方式

1. sh解析器执行方式
   语法: `sh 脚本文件`
   介绍: 就是利用sh命令执行脚本文件,  本质就是使用Shell解析器运行脚本文件

2. bash解析器执行方式（常用）
   语法: `bash 脚本文件`
   介绍: 就是利用bash命令执行脚本文件,  本质就是使用Shell解析器运行脚本文件

3. 仅路径执行方式（常用）
   语法: `./脚本文件`
   介绍:  执行当前目录下的脚本文件
   注意:  脚本文件自己执行需要具有可执行权限, 否则无法执行

## shell脚本编写流程

第一步：编写脚本文件-----vim 编辑的文件

第二步：加上可执行权限------**chmod +x xxxx.sh**

第三步：运行

## 环境变量

### 作用域：系统Shell配置文件提供,  全局都可以使用

| 分类                          | 初始化环境变量过程执行文件顺序                               |
| ----------------------------- | ------------------------------------------------------------ |
| shell登录环境变量初始化过程   | /etc/profile--》/etc/profile.d/*.sh--》~/.bash_profile--》~/.bashrc--》/etc/bashrc |
| shell非登录环境变量初始化过程 | ~/.bashrc--》/etc/bashrc--》/etc/profile.d/*.sh              |

### 系统环境变量

#### 查看当前Shell系统环境变量

查看命令

```shell
env    #查看环境变量
```

#### 常用系统环境变量

| 变量名称     | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| ==PATH==     | 与windows环境变量PATH功能一样，设置命令的搜索路径，以冒号为分割 |
| HOME         | 当前用户主目录：/root                                        |
| SHELL        | 当前shell解析器类型：/bin/baEsh                              |
| ==HISTFILE== | 显示当前用户执行命令的历史列表文件：/root/.bash_history      |
| PWD          | 显示当前所在路径：/root                                      |
| OLDPWD       | 显示之前的路径                                               |
| HOSTNAME     | 显示当前主机名                                               |
| HOSTTYPE     | 显示主机的架构，是i386、i686、还是x86、x64等：x86_64         |
| ==LANG==     | 设置当前系统语言环境：zh_CN.UTF-8                            |

### 自定义变量分类

#### 1、自定义局部变量

定义在一个脚本文件中的变量, 只能在这个脚本文件中使用的变量, 就是局部变量

定义语法

```shell
var_name=value    #变量名=变量值
```

注：变量定义规则

1. 变量名称可以有字母,数字和下划线组成, 但是不能以数字开头
2. 等号两侧不能有空格
3. 在bash环境中, 变量的默认类型都是字符串类型, 无法直接进行数值运算
4. 变量的值如果有空格, 必须使用双引号括起来
5. 不能使用Shell的关键字作为变量名称

##### 变量删除

```sh
unset 变量名=变量值   #清除变量值
```

##### 自定义常量

> 就是变量设置值以后不可以修改的变量叫常量, 也叫只读变量

```sh
readonly 变量名=变量值  #只读变量
```

#### 自定义全局变量

```sh
export 变量名=变量值  
```

#### 特殊变量

```sh
1. `$n`：这个特殊变量表示位置参数，其中n是一个数字。例如，$1表示第一个命令行参数，$2表示第二个命令行参数，依此类推。
2. `$#`：这个特殊变量表示传递给脚本或函数的参数数量。它可以用来确定有多少个参数被提供。
3. `$*` 与` $@`：这两个特殊变量都表示所有传递给脚本或函数的参数。它们之间有一些细微的差别：
   - `$*`：将所有参数视为一个整体，用第一个参数分隔。
   - `$@`：将所有参数视为独立的个体，每个参数都是一个单独的字符串。
4. `$?`：这个特殊变量表示最近执行的命令的退出状态。在Unix-like系统中，命令执行成功时通常返回0，而失败时返回非零值。通过检查$?的值，可以判断上一个命令是否成功执行。
5. `$$`：这个特殊变量表示当前脚本或函数的进程ID（PID）。它可以用于获取当前正在运行的脚本或函数的进程ID。

```

### 执行脚本传入参数

```sh
bash 脚本文件名称 输入参数1 输入参数2
```

#### 登录Shell与非登录Shell环境

| 类型名称        | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| shell登录环境   | 需要用户名、密码登录之后才能进入的shell                      |
| shell非登录环境 | 直接不用输入用户名和密码就可以打开的shell<br>或调用子Shell时使用的工作环境 |

### 识别Shell环境类型

#### 识别shell环境的命令1

$0命令：识别环境语法

```shell
echo $0       #输出识别环境语法
```

输出 `-bash` 代表：shell登录环境

输出 `bash` 代表：  shell非登录环境

 注意：这个 `$0` 环境变量如果用在子shell中(shell脚本文件)输出Shell脚本本身的文件名 

bash命令：切换非登录环境

```shell
bash
```

su 用户名 -l切换登陆环境

```
su 用户名 -l
```

bash命令：用于切换为Shell非登录环境


|           分类            | 命令介绍                                                     |
| :-----------------------: | ------------------------------------------------------------ |
|  切换为shell登录环境命令  | 方式1：直接使用用户名与密码登录系统 方式2：bash -l  shell脚本文件   或   bash --login  shell脚本文件 方式3：su 用户名  --login 或 -l |
| 切换为shell非登录环境命令 | 方式1：bash 方式2：su 用户名                                 |

## shell字符串变量

1.使用单引号 `''`  的字符串：
任何字符都会原样输出，在其中使用变量是无效的。

2.由双引号`" "`包围的字符串：
其中包含了变量，那么该变量会被解析得到值，而不是原样输出。
字符串中还可以出现双引号的子字符串，但是需要转义。

3.不被引号包围的字符串
不被引号包围的字符串中出现变量时也会被解析，这一点和双引号`" "`包围的字符串一样。
字符串中不能出现空格，否则空格后边的字符串会作为其他变量或者命令解析。

### 获取字符串的长度

```
${#变量名}
```

### 字符串截取语法

| 格式                       | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `${变量名:start:length}`   | 从 string 字符串的左边第 start 个字符开始， 向右截取 length 个字符。 |
| `${变量名:start}`          | 从 string 字符串的左边第 start 个字符开始截取，直到最后。    |
| `${变量名:0-start:length}` | 从 string 字符串的右边第 start 个字符开始， 向右截取 length 个字符。 |
| `${变量名:0-start}`        | 从 string 字符串的右边第 start 个字符开始截取，直到最后。    |
| `${变量名#*chars}`         | 从 string 字符串第一次出现 *chars 的位置开始， 截取 *chars 右边的所有字符。 |
| `${变量名##*chars}`        | 从 string 字符串最后一次出现 *chars 的位置开始， 截取 *chars 右边的所有字符。 |
| `${变量名%chars*}`         | 从 string 字符串最后第一次出现 chars* 的位置开始， 截取 chars* 左边的所有字符。 |
| `${变量名%%chars*}`        | 从 string 字符串第一次出现 chars* 的位置开始， 截取 chars* 左边的所有字符 |

### 数组的定义

语法：

- 在 Shell 中，用括号`( )`来表示数组，数组元素之间用空格来分隔. 语法为：


```shell
array1=(1 2 3)  # 方式1
array2=([0]=0 [1]=1 [2]=2)  # 方式2
```

> 注意，赋值号 `=` 两边不能有空格

### 数组的拼接

所谓 Shell 数组拼接（数组合并），就是将两个数组连接成一个数组

语法：

- 使用 `@` 和 `*` 获取数组所有元素之后进行拼接


```shell
数组名=(${数组1[@]} ${数组2[@]} ...)
数组名=(${数组1[*]} ${数组2[*]} ...)
```

### 数组的删除

语法：

- 删除数组指定元素数据


```shell
unset 数组名[索引]
```

- 删除整个数组


```shell
unset 数组名
```

## Shell内置命令

使用type 来确定一个命令是否是内置命令：

```shell
type 命令
```

### 内置命令列表

| 命令        | 说明                                                  |
| ----------- | ----------------------------------------------------- |
| :           | 扩展参数列表，执行重定向操作                          |
| .           | 读取并执行指定文件中的命令（在当前 shell 环境中）     |
| ==alias==   | 为指定命令定义一个别名                                |
| bg          | 将作业以后台模式运行                                  |
| bind        | 将键盘序列绑定到一个 readline 函数或宏                |
| break       | 退出 for、while、select 或 until 循环                 |
| builtin     | 执行指定的 shell 内建命令                             |
| caller      | 返回活动子函数调用的上下文                            |
| cd          | 将当前目录切换为指定的目录                            |
| command     | 执行指定的命令，无需进行通常的 shell 查找             |
| compgen     | 为指定单词生成可能的补全匹配                          |
| complete    | 显示指定的单词是如何补全的                            |
| compopt     | 修改指定单词的补全选项                                |
| continue    | 继续执行 for、while、select 或 until 循环的下一次迭代 |
| ==declare== | 声明一个变量或变量类型。                              |
| dirs        | 显示当前存储目录的列表                                |
| disown      | 从进程作业表中刪除指定的作业                          |
| ==echo==    | 将指定字符串输出到 STDOUT                             |
| enable      | 启用或禁用指定的内建shell命令                         |
| eval        | 将指定的参数拼接成一个命令，然后执行该命令            |
| exec        | 用指定命令替换 shell 进程                             |
| ==exit==    | 强制 shell 以指定的退出状态码退出                     |
| export      | 设置子 shell 进程可用的变量                           |
| fc          | 从历史记录中选择命令列表                              |
| fg          | 将作业以前台模式运行                                  |
| getopts     | 分析指定的位置参数                                    |
| hash        | 查找并记住指定命令的全路径名                          |
| help        | 显示帮助文件                                          |
| history     | 显示命令历史记录                                      |
| jobs        | 列出活动作业                                          |
| kill        | 向指定的进程 ID(PID) 发送一个系统信号                 |
| let         | 计算一个数学表达式中的每个参数                        |
| local       | 在函数中创建一个作用域受限的变量                      |
| logout      | 退出登录 shell                                        |
| mapfile     | 从 STDIN 读取数据行，并将其加入索引数组               |
| popd        | 从目录栈中删除记录                                    |
| printf      | 使用格式化字符串显示文本                              |
| pushd       | 向目录栈添加一个目录                                  |
| pwd         | 显示当前工作目录的路径名                              |
| ==read==    | 从 STDIN 读取一行数据并将其赋给一个变量               |
| readarray   | 从 STDIN 读取数据行并将其放入索引数组                 |
| readonly    | 从 STDIN 读取一行数据并将其赋给一个不可修改的变量     |
| return      | 强制函数以某个值退出，这个值可以被调用脚本提取        |
| set         | 设置并显示环境变量的值和 shell 属性                   |
| shift       | 将位置参数依次向下降一个位置                          |
| shopt       | 打开/关闭控制 shell 可选行为的变量值                  |
| source      | 读取并执行指定文件中的命令（在当前 shell 环境中）     |
| suspend     | 暂停 Shell 的执行，直到收到一个 SIGCONT 信号          |
| test        | 基于指定条件返回退出状态码 0 或 1                     |
| times       | 显示累计的用户和系统时间                              |
| trap        | 如果收到了指定的系统信号，执行指定的命令              |
| type        | 显示指定的单词如果作为命令将会如何被解释              |
| typeset     | 声明一个变量或变量类型。                              |
| ulimit      | 为系统用户设置指定的资源的上限                        |
| umask       | 为新建的文件和目录设置默认权限                        |
| unalias     | 刪除指定的别名                                        |
| unset       | 刪除指定的环境变量或 shell 属性                       |
| wait        | 等待指定的进程完成，并返回退出状态码                  |

#### alis内置命令

介绍：

alias 用于给命令创建别名。若该命令且不带任何参数，则显示当前 Shell 进程中的所有别名列表。

**alias别名定义语法：**

```shell
alias 别名='命令'
```

**unalias 别名删除语法：**

删除指定的别名

```shell
unalias 别名
```

删除当前Shell环境中所有的别名

```shell
unalias -a
```

> 注意:  以上2种方式删除都是临时删除当前Shell的别名,  如果想永久删除必须去配置文件中手动删除

```sh
vim /etc/profile
文件末尾添加
alias ccdd=cd
更新
source /etc/profile    

补充说明
job   #
bg    #进程放后台执行
```

#### echo内置命令

- `-e` 参数

- `-e` 参数用于解析转义字符

- \n换行

- `\c` 转义字符

- `\c` 用于强制清除echo的结尾换行输出

#### read内置命令

介绍：

read 是 Shell 内置命令，用于从标准输入中读取数据并赋值给变量。如果没有进行重定向，默认就是从终端控制台读取用户输入的数据；如果进行了重定向，那么可以从文件中读取数据。

语法：

```shell
read [-options] [var1 var2 ...]
```

> `options`表示选项，如下表所示；`var`表示用来存储数据的变量，可以有一个，也可以有多个。
>
> `options`和`var`都是可选的，如果没有提供变量名，那么读取的数据将存放到环境变量 REPLY 中。

| 选项                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| -a array               | 把读取的数据赋值给数组 array，从下标 0 开始。                |
| -d delimiter（不常用） | 用字符串 delimiter 指定读取结束的位置，而不是一个换行符（读取到的数据不包括 delimiter）。 |
| -e（不常用）           | 在获取用户输入的时候，对功能键进行编码转换，不会直接显式功能键对应的字符。 |
| ==-n num==             | 读取 num 个字符，而不是整行字符。                            |
| ==-p  prompt==         | 显示提示信息，提示内容为 prompt。                            |
| -r                     | 原样读取（Raw mode），不把反斜杠字符解释为转义字符。         |
| ==-s==                 | 静默模式（Silent mode），不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这是很有必要的。 |
| ==-t seconds==         | 设置超时时间，单位为秒。如果用户没有在指定时间内输入完成，那么 read 将会返回一个非 0 的退出状态，表示读取失败。 |
| -u fd                  | 使用文件描述符 fd 作为输入源，而不是标准输入，类似于重定向。 |

#### exit内置命令

`exit` 用于退出当前 Shell 进程结束运行，并返回一个退出状态；使用`$?`可以接收这个退出状态.

exit 命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。

一般情况下，退出状态为 0 表示成功，退出状态为非 0 表示执行失败（出错）了。 

#### declare内置命令

介绍：

declare命令用于声明 shell 变量。可用来声明变量并设置变量的属性，也可用来显示shell函数。若不加上任何参数，则会显示全部的shell变量与函数(与执行set指令的效果相同)。

declare命令作用：

- declare设置变量的属性


语法：

- declare设置变量的属性语法

```shell
declare [+/-][aArxif][变量名称＝设置值]
```

> +/- 　"-"可用来指定变量的属性，"+"则是取消变量所设的属性。
>
> a    设置为普通索引数组
>
> A    设置为key-value关联数组
>
> r 　将变量设置为只读,  也可以使用readonly
>
> x 　设置变量成为环境变量，也可以使用export
>
> i 　设置为整型变量。
>
> f     设置为一个函数变量

## Shell运算符

### expr命令

介绍：

expr 是 evaluate expressions 的缩写，译为“表达式求值”。Shell expr 是一个功能强大，并且比较复杂的命令，它除了可以实现整数计算，还可以结合一些选项对字符串进行处理，例如计算字符串长度、字符串比较、字符串匹配、字符串提取等, 后续讲解。

语法：

计算语法

```shell
expr 算术运算符表达式
```

> 注意: 运算表达式

获取计算结果赋值给新变量语法

```shell
result=`expr 算术运算符表达式`
```

### 算术运算符

介绍：

- 下表列出了常用的算术运算符，假定变量 a 为 1，变量 b 为 2：


| 运算符 | 说明 | 举例                       |
| :----- | :--- | :------------------------- |
| +      | 加法 | `expr $a + $b` 结果为 3    |
| -      | 减法 | `expr $a - $b` 结果为 -1   |
| *      | 乘法 | `expr $a \* $b` 结果为  2  |
| /      | 除法 | `expr $b / $a` 结果为 2    |
| %      | 取余 | `expr $b % $a` 结果为 0    |
| =      | 赋值 | a=$b 将把变量 b 的值赋给 a |

> 四则运算中如果使用了(), 也需要转义 `\( 1 + 1 \)

### 比较运算符

#### 整数比较运算符

语法：

下表列出了常用的比较运算符，假定变量 a 为 1，变量 b 为 2：

| 运算符 | 说明                                                         | 举例                     |
| :----- | :----------------------------------------------------------- | :----------------------- |
| `-eq`  | equals 检测两个数是否相等，相等返回 0, 否则返回1。           | `[ $a -eq $b ]` 返回 1。 |
| `-ne`  | not equals检测两个数是否不相等，不相等返回 true。            | `[ $a -ne $b ]` 返回 0。 |
| `-gt`  | greater than检测左边的数是否大于右边的,<br>是返回0, 否则1    | `[ $a -gt $b ]` 返回 1。 |
| `-lt`  | lower than检测左边的数是否小于右边的,<br>是返回0, 否则1      | `[ $a -lt $b ]` 返回 0。 |
| `-ge`  | greater equals检测左边的数是否大于等于右边的,<br>是返回0, 否则1 | `[ $a -ge $b ] `返回 1。 |
| `-le`  | lower equals检测左边的数是否小于等于右边的,<br>是返回0, 否则1 | `[ $a -le $b ] `返回 0。 |
| `<`    | 检测左边的数是否小于右边的,<br/>是返回0, 否则1               | `(($a<$b))` 返回0        |
| `<=`   | 检测左边的数是否小于等于右边的,<br/>是返回0, 否则1           | `(($a<=$b))` 返回0       |
| `>`    | 检测左边的数是否大于右边的,<br/>是返回0, 否则1               | `(($a>$b))` 返回1        |
| `>=`   | 检测左边的数是否大于等于右边的,<br/>是返回0, 否则1           | `(($a>=$b))` 返回1       |

> 注意: 整数比较运算符只支持整数，不支持小数与字符串(字符串比较后续讲解)，除非字符串的值是整数数字。
>
> 每个命令都有返回值,  这个后面我们会讲解退出状态再具体说明,  返回0代表成功, 返回1代表失败

#### 字符串比较运算符

介绍：

可以比较2个变量, 变量的类型可以为数字（整数，小数）与字符串

语法：

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

字符串比较可以使用 `[[]]` 和 `[]` 2种方式

| 运算符  | 说明                                                      | 举例                                                         |
| :------ | :-------------------------------------------------------- | :----------------------------------------------------------- |
| == 或 = | 相等。用于比较两个字符串或数字，相同则返回 0。可以使用`=` | `[ $a == $b ] `返回1 <br>`[  $a = $b ]` 返回 1<br>`[[ $a == $b ]]` 返回1<br>`[[ $a = $b ]]` 返回1 |
| !=      | 不相等。用于比较两个字符串或数字，不相同则返回 0。        | `[ $a != $b ]` 返回 0<br>`[[ $a != $b ]]` 返回 0             |
| <       | 小于, 用于比较两个字符串或数字， 小于返回0， 否则返回1    | `[ $a \< $b ]` 返回 0<br/>`[[ $a < $b ]]` 返回 0             |
| >       | 大于, 用于比较两个字符串或数字， 大于返回0， 否则返回1    | `[ $a \> $b ]` 返回 1<br/>`[[ $a > $b ]]` 返回 1             |
| -z      | 检测字符串长度是否为0，为0返回 true。                     | [ -z $a ] 返回 1。                                           |
| -n      | 检测字符串长度是否不为 0，不为 0 返回 true。              | [ -n "$a" ] 返回 0。                                         |
| $       | 检测字符串是否不为空，不为空返回 0 ,否则返回1。           | [ $a ] 返回 0。                                              |

> 字符串比较没有 `<=`  可以通过 `[[ "a" < "b" && "a" = "b" ]]

### `[[]]`  和 `[]` 的区别

1. 兼容性：[]是POSIX shell标准的一部分，被大多数shell（如Bourne shell, ash, dash等）所兼容。而[[]]是bash特有的语法扩展，不是所有shell都支持。
2. 功能性：[[]]比[]提供了更多的功能。例如，[[]]支持模式匹配操作符=~（正则表达式匹配），而[]不支持。此外，[[]]对于变量和字符串的比较更为严格，不会将未引用的变量扩展为空值。
3. 操作符：在[[]]中，可以使用&&和||作为逻辑AND和OR操作符，而在[]中，需要使用-a和-o。
4. 引号使用：在[[]]中，即使变量没有引用，也可以安全地进行字符串比较；而在[]中，为了避免路径名扩展等问题，通常需要对变量进行引用。
5. 空格要求：[[]]允许在操作符两侧有空格，而[]通常不允许这样的空格。
6. 退出状态：当[[]]中的条件为假时，它返回一个非零的退出状态，而[]可能不会。

### 布尔运算符

| 运算符 | 说明                                                         | 举例                                  |
| :----- | :----------------------------------------------------------- | :------------------------------------ |
| !      | 非运算，取反, 表达式为 true 则返回 false，<br>否则返回 true。 | `[ ! false ]` 返回 true。             |
| -o     | or 或运算，有一个表达式为 true 则返回 true。                 | `[ 表达式1 -o 表达式2 ]` 返回 true。  |
| -a     | and 与运算，两个表达式都为 true 才返回 true。                | `[ 表达式1 -a 表达式2 ]` 返回 false。 |

> 注意布尔运算符只能放在`[]`  才有效  
>
> 以后常使用布尔运算符与test命令进行连接条件测试, 后续讲解

### 逻辑运算符

| 运算符 | 说明       | 举例                            |
| :----- | :--------- | :------------------------------ |
| &&     | 逻辑的 AND | `[[ 表达式1 && 表达式2 ]]` ，且 |
| \|\|   | 逻辑的 OR  | `[[ 表达式1                     |

> 注意:  使用`&&`  和  `||`  的运算符必须放在 `[[]]`  或 `(())`中才有效, 否则报错
>
> `-a` 和 `-o` 的运算符必须放在 `[]` 在才有效 或 test命令中
>
> !可以用在`[]`,`[[]]`中, 不可以在(())

### 文件测试运算符

1. `-b file`: 检查文件是否为一个块设备文件。
2. `-c file`: 检查文件是否为一个字符设备文件。
3. `-d file`: 检查文件是否为一个目录。
4. `-e file`: 检查文件是否存在。
5. `-f file`: 检查文件是否为一个普通文件。
6. `-g file`: 检查文件是否设置了setgid位。
7. `-G file`: 检查文件是否为一个具有组ID的可执行文件。
8. `-h file`: 检查文件是否为一个符号链接。
9. `-k file`: 检查文件是否设置了粘滞位。
10. `-L file`: 检查文件是否为一个符号链接。
11. `-n file`: 检查文件的大小是否非零。
12. `-O file`: 检查当前用户是否拥有文件。
13. `-p file`: 检查文件是否为一个命名管道（FIFO）。
14. `-r file`: 检查文件是否可读。
15. `-s file`: 检查文件的大小是否非零。
16. `-S file`: 检查文件是否为一个套接字。
17. `-t file`: 检查文件描述符是否打开。
18. `-u file`: 检查文件是否设置了setuid位。
19. `-w file`: 检查文件是否可写。
20. `-x file`: 检查文件是否可执行。
21. `-z file`: 检查文件的大小是否为零。

# 流程控制语句

### if else语句

**介绍**

if条件判断逻辑控制语句

**if语法**

多行写法语法

```shell
if [ 条件 ]; then
    命令
fi
```

### if else 语法

```shell
if [ 条件 ]; then
    命令1
else
    命令2
fi
```

### if elif else 语法

```shell
if [ 条件1 ]; then
    命令1
elif [ 条件2 ]; then
    命令2
elif [ 条件3 ]; then
    命令3
...
else
   命令N
fi
```

### case条件判断 

```shell
case语句和if elif else 是一样的，都是多分支条件语句，不过和if的不同点是 case只能判断一个条件，if可以判断多种条件。

语法：
case $变量名 in
	"值1")
		如果值是1，执行1程序
	;;
	"值2")
		如果值是2，执行2程序
	;;
	......
	*)
		如果所有值都不是上面的值，就执行此程序
	;;
esac
```

### for循环

```shell
for循环是固定循环，在循环之前就已经知道自己需要循环几次，for循环又被我们称为计数循环

语法1：
for 变量 in 值1 值2 值3 ...
	do
		程序
	done
	
这个for循环次数，取决于in后面值的个数，有几个值就循环几次，并且每次循环都把值放到变量里面去，假设in后面有四个值，for循环就会循环四次，第一次会把值1 给到变量，第二次会把值2 给到变量.... 依此类推

一行写法 for 变量 in {start..end}; do 命令; done

语法2:
for (( 初始值;循环控制条件;变量变化 ))
	do
		程序
	done
初始值，在循环开始之前，把某个变量赋予初始值，比方说 i=1
循环控制条件，用于指定变量循环的次数，比方是 i<=10 ，循环就会一直继续
变量变化，就是每循环一次，变量该怎么去变化，比方i=i+1,代表每次循环之后，i的变量都会加1

无限循环
for((;;)); do 命令; done

```

### while循环

```shell
while 条件
do
    命令1
    命令2
    ...
    continue; # 结束当前这一次循环, 进入下一次循环
    break; # 结束当前循环
done

一行写法 while 条件; do 命令; done;
```

# shell函数

### basename系统函数

#### 介绍

basename函数用于获取文件名的函数,  根据给出的文件路径截取出文件名

#### 语法

```shell
basename [string / pathname] [suffix]  
```

> 根据根据指定字符串或路径名进行截取文件名,  比如:  根据路径"/one/two/aa.txt",  可以截取出aa.txt
>
> suffix: 用于截取的时候去掉指定的后缀名.

### (())命令详解

#### 介绍

- 双小括号 (( )) , 用于进行数学运算表达式的执行 , 将数学运算表达式放在`((`和`))`之间。

- 可以使用`$`获取 (( )) 表达式命令的结果，这和使用`$`获得变量值是一样的。


### dirname系统函数

#### 介绍

从指定的文件绝对路径,  去除文件名，返回剩下的前缀目录路径

#### 语法

```shell
dirname 文件绝对路径
```

### 自定义函数

#### 介绍

开发人员可以通过自定义开发函数,实现代码重用.

#### 语法

```shell
# 函数的定义
[ function ] funname ()
{
    命令
    [return 返回值]

}

# 调用函数
funname 传递参数1 传递参数2 ...
```

> 1. 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
>
> 2. 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0~255)

#### 注意

必须在调用函数地方之前，先声明函数，shell脚本是逐行运行,  只要先运行了函数, 后面才可以时使用函数



# 文本工具

1. grep：它是一个强大的文本搜索工具，可以使用正则表达式搜索文本，并把匹配的行打印出来。grep的全称是Global Regular Expression Print，即全局正则表达式版本，它被用于查找或匹配文件中的文本内容。
2. sed（Stream Editor的缩写）：它是一个用来进行基本文本转换的命令，特别适合于编辑匹配到的文本。sed能够基于输入的脚本命令来处理文本文件，实现如删除、替换以及新增等操作。
3. awk：它是一种编程语言，用于在文件中查找和处理模式。Awk的功能非常强大，可以处理复杂的文本格式处理任务，比如格式化输出、计算数据字段以及进行条件判断等。
4. sort命令是Linux系统中一个非常实用的文本处理工具，用于对文本文件的行进行排序

## cut命令

语法：

```shell
cut [options]  filename

#切割提取IP地址
ifconfig | grep broadcast | cut -d " " -f 10
#切割提取bash进程的pid号
ps -aux | grep 'bash' | head -n 1 | cut -d " " -f 8

cut切割提取列
> `cut  文件或数据 -d 分隔符切割 -f 提取第X列 `

cut切割提取字符（一个汉字三个字符）
> `cut  文件或数据 -c 提取字符范围 `

cut切割提取字节
> `cut  文件或数据 -nb 提取直接范围 `
```

options参数说明

| 选项参数        | 功能                                                         |
| --------------- | ------------------------------------------------------------ |
| -f 提取范围     | 列号，获取第几列                                             |
| -d 自定义分隔符 | 自定义分隔符，默认为制表符。                                 |
| -c 提取范围     | 以字符为单位进行分割                                         |
| -b 提取范围     | 以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。 |
| -n              | 与“-b”选项连用，不分割多字节字符；                           |

提取范围说明

| 提取范围  | 说明                                                       |
| --------- | ---------------------------------------------------------- |
| n-        | 提取指定第n列或字符或字节后面所有数据                      |
| n-m       | 提取指定第n列或字符或字节到第m列或字符或字节中间的所有数据 |
| -m        | 提取指定第m列或字符或字节前面所有数据                      |
| n1,n2,... | 提前指定枚举列的所有数据                                   |

## sed命令

语法：

```sehll
sed [选项参数] [模式匹配/sed程序命令] [文件名]

# 模式匹配,sed会读取每一行数据到模式空间中, 之后判断当前行是否符合模式匹配要求,符合要求就会
# 执行sed程序命令, 否则不会执行sed程序命令;如果不写匹配模式,那么每一行都会执行sex程序命令
```

选项参数说明

| 选项参数                   | 功能                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `-e`                       | 直接在指令列模式上进行sed的动作编辑。它告诉sed将下一个参数解释为一个sed指令，只有当命令行上给出多个sed指令时才需要使用-e选项;一行命令语句可以执行多条sed命令 |
| `-i`                       | 直接对内容进行修改，不加-i时默认只是预览，不会对文件做实际修改 |
| `-f`                       | 后跟保存了sed指令的文件                                      |
| `-n`                       | 取消默认输出，sed默认会输出所有文本内容，使用-n参数后只显示处理过的行 |
| `-r ruguler              ` | 使用扩展正则表达式，默认情况sed只识别基本正则表达式 *        |

sed程序命令功能描述

| 命令 | 功能描述                                      |
| ---- | --------------------------------------------- |
| `a`  | add新增，a的后面可以接字串，在下一行出现      |
| `c`  | change更改, 更改匹配行的内容                  |
| d    | delete删除, 删除匹配的内容                    |
| `i`  | insert插入, 向匹配行前插入内容                |
| `p`  | print打印, 打印出匹配的内容，通常与-n选项和用 |
| s    | substitute替换, 替换掉匹配的内容              |
| `=`  | 用来打印被匹配的行的行号                      |
| `n`  | 读取下一行，遇到n时会自动跳入下一行           |

特殊符号

| 命令                | 功能描述                                                     |
| ------------------- | ------------------------------------------------------------ |
| `!`                 | 就像一个sed命令，放在限制条件后面, 对指定行以外的所有行应用命令(取反) |
| {sed命令1;sed命令2} | 多个命令操作同一个的行                                       |

### 关于缓存区sed程度命令

| 命令 | 含义                                                       |
| ---- | ---------------------------------------------------------- |
| h    | 将**模式空间**里面的内容复制到**暂存空间**缓存区(覆盖方式) |
| H    | 将**模式空间**里面的内容复制到**暂存空间**缓存区(追加方式) |
| g    | 将**暂存空间**里面的内容复制到**模式空间**缓存区(覆盖方式) |
| G    | 将**暂存空间**里面的内容复制到**模式空间**缓存区(追加方式) |
| x    | 交换2个空间的内容                                          |

## awk命令：

语法：

```shell
awk [options] 'pattern{action}' {filenames}
```

> pattern：表示AWK在数据中查找的内容，就是匹配模式
>
> action：在找到匹配内容时所执行的一系列命令

选项参数说明

| 选项参数 | 功能                   |
| -------- | ---------------------- |
| -F       | 指定输入文件拆分分隔符 |
| -v       | 赋值一个用户定义变量   |

### awk内置变量

| 内置变量 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| ARGC     | 命令行参数个数                                               |
| ARGV     | 命令行参数排列                                               |
| ENVIRON  | 支持队列中系统环境变量的使用                                 |
| FILENAME | awk浏览的文件名                                              |
| FNR      | 浏览文件的记录数                                             |
| FS       | 设置输入域分隔符，等价于命令行 -F选项                        |
| NF       | 浏览记录的域的个数, 根据分隔符分割后的列数                   |
| NR       | 已读的记录数, 也是行号                                       |
| OFS      | 输出域分隔符                                                 |
| ORS      | 输出记录分隔符                                               |
| RS       | 控制记录分隔符                                               |
| `$n`     | `$0`变量是指整条记录。`$1`表示当前行的第一个域,`$2`表示当前行的第二个域,......以此类推。 |
| $NF      | $NF是number finally,表示最后一列的信息，跟变量NF是有区别的，变量NF统计的是每行列的总数 |

## sort命令

语法：

```shell
sort (options) 参数
```

| 选项            | 说明                                                     |
| --------------- | -------------------------------------------------------- |
| ==-n==          | number,依照数值的大小排序                                |
| ==-r==          | reverse, 以相反的顺序来排序                              |
| ==-t 分隔字符== | 设置排序时所用的分隔字符, 默认空格是分隔符               |
| ==-k==          | 指定需要排序的列                                         |
| -d              | 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。 |
| -f              | 排序时，将小写字母视为大写字母                           |
| -b              | 忽略每行前面开始出的空格字符                             |
| ==-o 输出文件== | 将排序后的结果存入指定的文件                             |
| -u              | 意味着是唯一的(unique)，输出的结果是去完重了的           |
| -m              | 将几个排序好的文件进行合并                               |
